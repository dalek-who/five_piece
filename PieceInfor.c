//一共四个函数，分别提取行，列，左斜，右斜方向的棋型的数字特征。四个函数几乎完全相同，唯一的区别在于移动的是横坐标还是纵坐标
#include"five_piece.h"

//抓取行方向的棋型信息
//player：当前玩家的棋子颜色；think_x,yhink_y：带思考的落子位置；ThinkBoard[]当前的棋盘格局，*ppiece：指向一点棋型信息结构piece的指针
void hang_infor(int player,int think_x,int think_y,int ThinkBoard[SIZE][SIZE],piece *ppiece){

    //先用这些变量进行计算，算完后最后赋值给结构
    int line=1;//标记连子个数
    int live=0,block=0;//连子的两端，每出现一个空格，++live；每出现一个其他子或边界，++block
    int space=1;//可用的空间数。如果一个子周围的区域不可能放下五个子，则成绩应标为DEATH
    
    //用来存储一个待定点周围信息的相关参数。左左端点（LL），左跳连子（Ljump），左端点（L），落点附近连子数（line），右端点（R），右跳连子（Rjump），右右端点（RR）
    //跳连子位置是空出来的，标0（0个跳连子也是算跳连子）；跳连子位置被对方子占据or出界，标-1，代表没有跳连子
    int LL=0,Ljump=0,L=0,R=0,Rjump=0,RR=0;

    //临时坐标参数
    int i,j;
/*    
    //信息初始化
    ppiece->LL=0;
    ppiece->Ljump=0;
    ppiece->L=0,R=0;
    ppiece->Rjump=0;
    ppiece->RR=0;
    ppiece->line=1;
    
    ppiece->live=0;
    ppiece->block=0;
    ppiece->space=1;
    ppiece->l3=0;
    ppiece->rl4=0;
    ppiece->long=0;
    ppiece->score=0;
*/

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录右边相应参数
    ///////////////////////////////////////////////////

    //计算从该点起的连子个数
    for(i=think_x,j=think_y+1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        ++j,++line)
    ;
    //记录R
    if(i<=14&&i>=0&&j<=14&&j>=0)
        R=ThinkBoard[i][j];//R未出界
    else {R=OUT;Rjump=-1;RR=OUT;}//R出界
    
    //一头没被堵住就有一个live，被堵就有一个block
    if(R==0)
        ++live;
    else ++block;

    if(R!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i][j+1]!=0 && ThinkBoard[i][j+1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i>14 || i<0 || j+1>14 || j+1<0  )   //跳子位置越界
            Rjump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(++j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                ++j,++Rjump)
            ;
        }
        
        //记录右右端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            RR=ThinkBoard[i][j];//R未出界
        else RR=OUT;//R出界
    }
  
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录左边相应参数
    ///////////////////////////////////////////////////
    //计算从该点起的连子个数
    for(i=think_x,j=think_y-1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        --j,++line)
    ;
    //记录L
    if(i<=14&&i>=0&&j<=14&&j>=0)
        L=ThinkBoard[i][j];//L未出界
    else {L=OUT;Ljump=-1;LL=OUT;}//L出界

    //一头没就有一个live，被堵就有一个block
    if(L==0)
        ++live;
    else ++block;

    if(L!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i][j-1]!=0 && ThinkBoard[i][j-1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i>14 || i<0 || j-1>14 || j-1<0  )   //跳子位置越界
            Ljump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(--j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                --j,++Ljump)
            ;
        }
        
        //记录左左端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            LL=ThinkBoard[i][j];//L未出界
        else LL=OUT;//L出界
    }

    //计算一点周围最多可以落的子数
    //虽然两边没被直接堵住，但如果一个区域最多只能落四个子，则这个点也是个死子
    for(i=think_x,j=think_y+1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        ++j,++space)
    ;

    for(i=think_x,j=think_y-1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        --j,++space)
    ;

/*
//计算禁手模块所需参数    
    if(line>5)//长连数量
        ++*plongline;
    if(live>=1&&line==4)//双4数量
        ++*pnum_rl4;
    if(live==2&&line==3)//双活3数量
        ++*pnum_l3;
*/

/*
//返回打分的成绩
    if(line==5)
        return FIVE;//出现五连子。超过五连子是禁手，这里暂不考虑，后续会在外面补充禁手模块
    else if(block==2)
        return DIE;//两头被堵死
    else if(space<5)
        return DIE;//空间不够五个子
    else
        return pow(LINE,line)+live*LIVE;//活（两头都没被堵）或者眠（一头被堵，另一头没被堵）。此处LINE定义为100，LIVE定义为20，在头文件five_piece.h里
*/
    //返回棋型信息
    ppiece->LL       =LL;
    ppiece->Ljump    =Ljump;
    ppiece->L        =L;
    ppiece->line     =line;
    ppiece->R        =R;
    ppiece->Rjump    =Rjump;
    ppiece->RR       =RR;
    
    ppiece->live     =live;
    ppiece->block    =block;
    ppiece->space    =space;
}



//2
//抓取列方向的棋型信息
void lie_infor(int player,int think_x,int think_y,int ThinkBoard[SIZE][SIZE],piece *ppiece){

    //先用这些变量进行计算，算完后最后赋值给结构
    int line=1;//标记连子个数
    int live=0,block=0;//连子的两端，每出现一个空格，++live；每出现一个其他子或边界，++block
    int space=1;//可用的空间数。如果一个子周围的区域不可能放下五个子，则成绩应标为DEATH
    
    //用来存储一个待定点周围信息的相关参数。左左端点（LL），左跳连子（Ljump），左端点（L），落点附近连子数（line），右端点（R），右跳连子（Rjump），右右端点（RR）
    //跳连子位置是空出来的，标0（0个跳连子也是算跳连子）；跳连子位置被对方子占据or出界，标-1，代表没有跳连子
    int LL=0,Ljump=0,L=0,R=0,Rjump=0,RR=0;

    //临时坐标参数
    int i,j;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录右边相应参数
    ///////////////////////////////////////////////////

    //计算从该点起的连子个数
    for(i=think_x+1,j=think_y;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        ++i,++line)
    ;
    //记录R
    if(i<=14&&i>=0&&j<=14&&j>=0)
        R=ThinkBoard[i][j];//R未出界
    else {R=OUT;Rjump=-1;RR=OUT;}//R出界
    
    //一头没被堵住就有一个live，被堵就有一个block
    if(R==0)
        ++live;
    else ++block;

    if(R!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i+1][j]!=0 && ThinkBoard[i+1][j]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i+1>14 || i+1<0 || j>14|| j<0  )   //跳子位置越界
            Rjump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(++i;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                ++i,++Rjump)
            ;
        }
        
        //记录右右端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            RR=ThinkBoard[i][j];//R未出界
        else RR=OUT;//R出界
    }
  
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录左边相应参数
    ///////////////////////////////////////////////////
    //计算从该点起的连子个数
    for(i=think_x-1,j=think_y;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        --i,++line)
    ;
    //记录L
    if(i<=14&&i>=0&&j<=14&&j>=0)
        L=ThinkBoard[i][j];//L未出界
    else {L=OUT;Ljump=-1;LL=OUT;}//L出界

    //一头没就有一个live，被堵就有一个block
    if(L==0)
        ++live;
    else ++block;

    if(L!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i-1][j]!=0 && ThinkBoard[i-1][j]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i-1>14 || i-1<0 || j>14 || j<0  )   //跳子位置越界
            Ljump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(--i;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                --i,++Ljump)
            ;
        }
        
        //记录左左端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            LL=ThinkBoard[i][j];//L未出界
        else LL=OUT;//L出界
    }

    //计算一点周围最多可以落的子数
    //虽然两边没被直接堵住，但如果一个区域最多只能落四个子，则这个点也是个死子
    for(i=think_x+1,j=think_y;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        ++i,++space)
    ;

    for(i=think_x-1,j=think_y;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        --i,++space)
    ;
    
    //返回棋型信息
    ppiece->LL       =LL;
    ppiece->Ljump    =Ljump;
    ppiece->L        =L;
    ppiece->line     =line;
    ppiece->R        =R;
    ppiece->Rjump    =Rjump;
    ppiece->RR       =RR;
    
    ppiece->live     =live;
    ppiece->block    =block;
    ppiece->space    =space;
}

//3
//抓取斜右下方向的棋型信息
void xie1_infor(int player,int think_x,int think_y,int ThinkBoard[SIZE][SIZE],piece *ppiece){

    //先用这些变量进行计算，算完后最后赋值给结构
    int line=1;//标记连子个数
    int live=0,block=0;//连子的两端，每出现一个空格，++live；每出现一个其他子或边界，++block
    int space=1;//可用的空间数。如果一个子周围的区域不可能放下五个子，则成绩应标为DEATH
    
    //用来存储一个待定点周围信息的相关参数。左左端点（LL），左跳连子（Ljump），左端点（L），落点附近连子数（line），右端点（R），右跳连子（Rjump），右右端点（RR）
    //跳连子位置是空出来的，标0（0个跳连子也是算跳连子）；跳连子位置被对方子占据or出界，标-1，代表没有跳连子
    int LL=0,Ljump=0,L=0,R=0,Rjump=0,RR=0;

    //临时坐标参数
    int i,j;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录右边相应参数
    ///////////////////////////////////////////////////

    //计算从该点起的连子个数
    for(i=think_x+1,j=think_y+1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        ++i,++j,++line)
    ;
    //记录R
    if(i<=14&&i>=0&&j<=14&&j>=0)
        R=ThinkBoard[i][j];//R未出界
    else {R=OUT;Rjump=-1;RR=OUT;}//R出界
    
    //一头没被堵住就有一个live，被堵就有一个block
    if(R==0)
        ++live;
    else ++block;

    if(R!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i+1][j+1]!=0 && ThinkBoard[i+1][j+1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i+1>14 || i+1<0 || j+1>14 || j+1<0  )   //跳子位置越界
            Rjump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(++i,++j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                ++i,++j,++Rjump)
            ;
        }
        
        //记录右右端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            RR=ThinkBoard[i][j];//R未出界
        else RR=OUT;//R出界
    }
  
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录左边相应参数
    ///////////////////////////////////////////////////
    //计算从该点起的连子个数
    for(i=think_x-1,j=think_y-1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        --i,--j,++line)
    ;
    //记录L
    if(i<=14&&i>=0&&j<=14&&j>=0)
        L=ThinkBoard[i][j];//L未出界
    else {L=OUT;Ljump=-1;LL=OUT;}//L出界

    //一头没就有一个live，被堵就有一个block
    if(L==0)
        ++live;
    else ++block;

    if(L!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i-1][j-1]!=0 && ThinkBoard[i-1][j-1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i-1>14 || i-1<0 || j-1>14 || j-1<0  )   //跳子位置越界
            Ljump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(--i,--j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                --i,--j,++Ljump)
            ;
        }
        
        //记录左左端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            LL=ThinkBoard[i][j];//L未出界
        else LL=OUT;//L出界
    }

    //计算一点周围最多可以落的子数
    //虽然两边没被直接堵住，但如果一个区域最多只能落四个子，则这个点也是个死子
    for(i=think_x+1,j=think_y+1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        ++i,++j,++space)
    ;

    for(i=think_x-1,j=think_y-1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        --i,--j,++space)
    ;

    //返回棋型信息
    ppiece->LL       =LL;
    ppiece->Ljump    =Ljump;
    ppiece->L        =L;
    ppiece->line     =line;
    ppiece->R        =R;
    ppiece->Rjump    =Rjump;
    ppiece->RR       =RR;
    
    ppiece->live     =live;
    ppiece->block    =block;
    ppiece->space    =space;
}

//4
//抓取斜右上方向的棋型信息
void xie2_infor(int player,int think_x,int think_y,int ThinkBoard[SIZE][SIZE],piece *ppiece){

    //先用这些变量进行计算，算完后最后赋值给结构
    int line=1;//标记连子个数
    int live=0,block=0;//连子的两端，每出现一个空格，++live；每出现一个其他子或边界，++block
    int space=1;//可用的空间数。如果一个子周围的区域不可能放下五个子，则成绩应标为DEATH
    
    //用来存储一个待定点周围信息的相关参数。左左端点（LL），左跳连子（Ljump），左端点（L），落点附近连子数（line），右端点（R），右跳连子（Rjump），右右端点（RR）
    //跳连子位置是空出来的，标0（0个跳连子也是算跳连子）；跳连子位置被对方子占据or出界，标-1，代表没有跳连子
    int LL=0,Ljump=0,L=0,R=0,Rjump=0,RR=0;

    //临时坐标参数
    int i,j;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录右边相应参数
    ///////////////////////////////////////////////////

    //计算从该点起的连子个数
    for(i=think_x-1,j=think_y+1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        --i,++j,++line)
    ;
    //记录R
    if(i<=14&&i>=0&&j<=14&&j>=0)
        R=ThinkBoard[i][j];//R未出界
    else {R=OUT;Rjump=-1;RR=OUT;}//R出界
    
    //一头没被堵住就有一个live，被堵就有一个block
    if(R==0)
        ++live;
    else ++block;

    if(R!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i-1][j+1]!=0 && ThinkBoard[i-1][j+1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i-1>14 || i-1<0 || j+1>14 || j+1<0  )   //跳子位置越界
            Rjump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(--i,++j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                --i,++j,++Rjump)
            ;
        }
        
        //记录右右端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            RR=ThinkBoard[i][j];//R未出界
        else RR=OUT;//R出界
    }
  
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    //记录左边相应参数
    ///////////////////////////////////////////////////
    //计算从该点起的连子个数
    for(i=think_x+1,j=think_y-1;
        ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
        ++i,--j,++line)
    ;
    //记录L
    if(i<=14&&i>=0&&j<=14&&j>=0)
        L=ThinkBoard[i][j];//L未出界
    else {L=OUT;Ljump=-1;LL=OUT;}//L出界

    //一头没就有一个live，被堵就有一个block
    if(L==0)
        ++live;
    else ++block;

    if(L!=OUT){
    //看是否有跳连子位置，以及跳连子个数
        if(   (ThinkBoard[i+1][j-1]!=0 && ThinkBoard[i+1][j-1]!=player) //跳子位置不是空格也不是自己的子（即是对方的子）
            || i+1>14 || i+1<0 || j-1>14 || j-1<0  )   //跳子位置越界
            Ljump=-1;//右边没有跳子位置
        
        //统计跳连子数量
        else{
            for(++i,--j;
                ThinkBoard[i][j]==player&&i<=14&&i>=0&&j<=14&&j>=0;
                ++i,--j,++Ljump)
            ;
        }
        
        //记录左左端点
        if(i<=14&&i>=0&&j<=14&&j>=0)
            LL=ThinkBoard[i][j];//L未出界
        else LL=OUT;//L出界
    }

    //计算一点周围最多可以落的子数
    //虽然两边没被直接堵住，但如果一个区域最多只能落四个子，则这个点也是个死子
    for(i=think_x-1,j=think_y+1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        --i,++j,++space)
    ;

    for(i=think_x+1,j=think_y-1;
        (ThinkBoard[i][j]==player||ThinkBoard[i][j]==0)&&i<=14&&i>=0&&j<=14&&j>=0;//是自己的子，或是空白，（不是对手的子，不碰到边界）都是可利用空间
        ++i,--j,++space)
    ;

    //返回棋型信息
    ppiece->LL       =LL;
    ppiece->Ljump    =Ljump;
    ppiece->L        =L;
    ppiece->line     =line;
    ppiece->R        =R;
    ppiece->Rjump    =Rjump;
    ppiece->RR       =RR;
    
    ppiece->live     =live;
    ppiece->block    =block;
    ppiece->space    =space;
}
